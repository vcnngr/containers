#!/usr/bin/env groovy
/**
 * VCNNGR Apache Pipeline
 * Build Apache HTTP Server container with quality checks
 */

pipeline {
    agent {
        kubernetes {
            namespace 'jenkins'
            yaml '''
apiVersion: v1
kind: Pod
metadata:
  labels:
    jenkins: agent
    container: apache
spec:
  serviceAccountName: jenkins
  securityContext:
    runAsUser: 0
    fsGroup: 0
  volumes:
  - name: docker-sock
    hostPath:
      path: /var/run/docker.sock
      type: Socket
  containers:
  - name: debian
    image: debian:bookworm
    command: [cat]
    tty: true
    securityContext:
      privileged: true
    resources:
      requests:
        memory: "4Gi"
        cpu: "2000m"
      limits:
        memory: "8Gi"
        cpu: "4000m"
    volumeMounts:
    - name: docker-sock
      mountPath: /var/run/docker.sock
    env:
    - name: DEBIAN_FRONTEND
      value: noninteractive
  - name: shellcheck
    image: koalaman/shellcheck-alpine:latest
    command: [cat]
    tty: true
  - name: sonar-scanner
    image: sonarsource/sonar-scanner-cli:latest
    command: [cat]
    tty: true
  - name: trivy
    image: aquasec/trivy:latest
    command: [cat]
    tty: true
    volumeMounts:
    - name: docker-sock
      mountPath: /var/run/docker.sock
'''
        }
    }
    
    parameters {
        string(name: 'APACHE_VERSION', defaultValue: '2.4.65', description: 'Apache version')
        string(name: 'IMAGE_REVISION', defaultValue: '0', description: 'Image revision')
        choice(name: 'DEBIAN_VARIANT', choices: ['debian-12', 'debian-11'], description: 'Debian variant')
        choice(name: 'BUILD_ARCH', choices: ['amd64', 'arm64'], description: 'Architecture')
        booleanParam(name: 'PUSH_TO_DOCKERHUB', defaultValue: false, description: 'Push to DockerHub')
        booleanParam(name: 'RUN_SECURITY_SCAN', defaultValue: true, description: 'Run security scan')
        booleanParam(name: 'RUN_CODE_QUALITY', defaultValue: true, description: 'Run code quality')
        booleanParam(name: 'TAG_AS_LATEST', defaultValue: false, description: 'Tag as latest')
    }
    
    environment {
        CONTAINER_NAME = 'apache'
        MAJOR_VERSION = sh(script: "echo '${params.APACHE_VERSION}' | cut -d. -f1-2", returnStdout: true).trim()
        DOCKERHUB_REGISTRY = 'docker.io'
        DOCKERHUB_NAMESPACE = 'vcnngr'
        IMAGE_BASE = "${DOCKERHUB_REGISTRY}/${DOCKERHUB_NAMESPACE}/${CONTAINER_NAME}"
        TAG_FULL = "${params.APACHE_VERSION}-${params.IMAGE_REVISION}"
        TAG_VERSION = "${params.APACHE_VERSION}"
        DOCKERHUB_CREDS = credentials('dockerhub-credentials')
        BUILD_CONTEXT = "${WORKSPACE}/${CONTAINER_NAME}/${MAJOR_VERSION}/${params.DEBIAN_VARIANT}"
        BUILD_DATE = sh(script: "date -u +'%Y-%m-%dT%H:%M:%SZ'", returnStdout: true).trim()
        GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 2, unit: 'HOURS')
        timestamps()
        ansiColor('xterm')
    }
    
    stages {
        stage('Setup') {
            steps {
                container('debian') {
                    sh '''
                        set -e
                        apt-get update -qq
                        apt-get install -y -qq docker.io curl git
                        docker version
                    '''
                }
            }
        }
        
        stage('Validate') {
            steps {
                script {
                    echo """
╔═══════════════════════════════════════════════════════════════╗
║              VCNNGR APACHE BUILD                              ║
╚═══════════════════════════════════════════════════════════════╝

Container:     ${CONTAINER_NAME}
Version:       ${params.APACHE_VERSION}
Revision:      ${params.IMAGE_REVISION}
Architecture:  ${params.BUILD_ARCH}
Build Date:    ${BUILD_DATE}
Git Commit:    ${GIT_COMMIT_SHORT}

Tags:
- ${IMAGE_BASE}:${TAG_FULL}
- ${IMAGE_BASE}:${TAG_VERSION}
- ${IMAGE_BASE}:${MAJOR_VERSION}
${params.TAG_AS_LATEST ? "• ${IMAGE_BASE}:latest" : ""}
═══════════════════════════════════════════════════════════════
"""
                    sh """
                        if [ ! -f "${BUILD_CONTEXT}/Dockerfile" ]; then
                            echo "ERROR: Dockerfile not found at ${BUILD_CONTEXT}/Dockerfile"
                            exit 1
                        fi
                        echo "✓ Dockerfile found"
                        
                        if [ -d "${BUILD_CONTEXT}/prebuildfs" ]; then
                            echo "✓ prebuildfs directory exists"
                        fi
                        
                        if [ -d "${BUILD_CONTEXT}/rootfs" ]; then
                            echo "✓ rootfs directory exists"
                        fi
                    """
                }
            }
        }
        
        stage('Code Quality') {
            when {
                expression { params.RUN_CODE_QUALITY }
            }
            parallel {
                stage('Shellcheck') {
                    steps {
                        container('shellcheck') {
                            script {
                                try {
                                    sh """
                                        cd ${BUILD_CONTEXT}
                                        SCRIPTS=\$(find . -type f -name '*.sh' 2>/dev/null || true)
                                        if [ -n "\$SCRIPTS" ]; then
                                            echo "\$SCRIPTS" | xargs shellcheck -f gcc --severity=warning || echo "Shellcheck warnings found"
                                        else
                                            echo "No shell scripts found"
                                        fi
                                    """
                                } catch (Exception e) {
                                    echo "Shellcheck failed: ${e.message}"
                                }
                            }
                        }
                    }
                }
                
                stage('SonarQube') {
                    steps {
                        container('sonar-scanner') {
                            script {
                                try {
                                    withCredentials([string(credentialsId: 'sonarqube-token', variable: 'SONAR_TOKEN')]) {
                                        sh """
                                            cd ${BUILD_CONTEXT}
                                            sonar-scanner \
                                                -Dsonar.host.url=http://sonarqube-sonarqube.jenkins.svc.cluster.local:9000 \
                                                -Dsonar.token=\${SONAR_TOKEN} \
                                                -Dsonar.projectKey=vcnngr-${CONTAINER_NAME} \
                                                -Dsonar.projectName='VCNNGR ${CONTAINER_NAME}' \
                                                -Dsonar.projectVersion=${params.APACHE_VERSION} \
                                                -Dsonar.sources=. \
                                                -Dsonar.exclusions='**/*.md'
                                        """
                                    }
                                } catch (Exception e) {
                                    echo "SonarQube failed: ${e.message}"
                                }
                            }
                        }
                    }
                }
            }
        }
        
        stage('Build Image') {
            steps {
                container('debian') {
                    sh """
                        cd ${BUILD_CONTEXT}
                        
                        # Crea il file secret per il Dockerfile
                        echo "minio.vcnngr.it/vcnngr-binaries" > ./downloads_url_secret
                        
                        # Build con Docker usando BuildKit per i secrets
                        export DOCKER_BUILDKIT=1
                        
                        docker build \
                            --secret id=downloads_url,src=./downloads_url_secret \
                            --build-arg TARGETARCH=${params.BUILD_ARCH} \
                            --build-arg DOWNLOADS_URL=minio.vcnngr.it/vcnngr-binaries \
                            --label "org.opencontainers.image.created=${BUILD_DATE}" \
                            --label "org.opencontainers.image.version=${params.APACHE_VERSION}" \
                            --label "org.opencontainers.image.vendor=Vcnngr" \
                            --tag ${IMAGE_BASE}:${TAG_FULL} \
                            --tag ${IMAGE_BASE}:${TAG_VERSION} \
                            --tag ${IMAGE_BASE}:${MAJOR_VERSION} \
                            ${params.TAG_AS_LATEST ? "--tag ${IMAGE_BASE}:latest" : ""} \
                            -f Dockerfile \
                            .
                        
                        # Cleanup secret file
                        rm -f ./downloads_url_secret
                        
                        echo "✓ Image built successfully"
                        docker images ${IMAGE_BASE}:${TAG_FULL}
                    """
                }
            }
        }
        
        stage('Test Image') {
            steps {
                container('debian') {
                    sh """
                        echo "Testing ${IMAGE_BASE}:${TAG_FULL}"
                        
                        echo "Test 1: Image starts correctly"
                        CONTAINER_ID=\$(docker run -d -p 8080:8080 ${IMAGE_BASE}:${TAG_FULL})
                        echo "Container started: \$CONTAINER_ID"
                        
                        # Aspetta che Apache sia pronto
                        echo "Waiting for Apache to start..."
                        sleep 15
                        
                        echo "Test 2: Container logs"
                        docker logs \$CONTAINER_ID | head -20
                        
                        echo "Test 3: HTTP Response"
                        # Installa curl se non presente
                        apt-get install -y curl 2>/dev/null || true
                        
                        RESPONSE=\$(docker exec \$CONTAINER_ID curl -s -o /dev/null -w "%{http_code}" http://localhost:8080 || echo "000")
                        
                        if [ "\$RESPONSE" = "200" ]; then
                            echo "✓ Apache responding with HTTP 200"
                        else
                            echo "ERROR: Apache returned HTTP \$RESPONSE"
                            docker logs \$CONTAINER_ID
                            docker stop \$CONTAINER_ID
                            docker rm \$CONTAINER_ID
                            exit 1
                        fi
                        
                        echo "Test 4: User verification"
                        USER=\$(docker exec \$CONTAINER_ID whoami || echo "unknown")
                        echo "Running as user: \$USER"
                        
                        echo "Test 5: Apache version"
                        docker exec \$CONTAINER_ID httpd -v || echo "Could not get Apache version"
                        
                        echo "Test 6: Process check"
                        docker exec \$CONTAINER_ID ps aux | grep httpd || true
                        
                        # Cleanup
                        docker stop \$CONTAINER_ID
                        docker rm \$CONTAINER_ID
                        
                        echo "✓ All tests passed"
                    """
                }
            }
        }
        
        stage('Security Scan') {
            when {
                expression { params.RUN_SECURITY_SCAN }
            }
            steps {
                container('trivy') {
                    script {
                        def maxRetries = 3
                        for (int attempt = 1; attempt <= maxRetries; attempt++) {
                            try {
                                if (attempt > 1) {
                                    sh "trivy clean --all || true"
                                    sleep(5)
                                }
                                
                                sh """
                                    trivy image \
                                        --severity HIGH,CRITICAL \
                                        --exit-code 0 \
                                        --timeout 10m \
                                        ${IMAGE_BASE}:${TAG_FULL}
                                    
                                    trivy image \
                                        --format json \
                                        --output trivy-report.json \
                                        ${IMAGE_BASE}:${TAG_FULL} || true
                                """
                                break
                            } catch (Exception e) {
                                if (attempt == maxRetries) {
                                    echo "Security scan failed after ${maxRetries} attempts"
                                }
                            }
                        }
                    }
                }
            }
        }
        
        stage('Push to DockerHub') {
            when {
                expression { params.PUSH_TO_DOCKERHUB }
            }
            steps {
                container('debian') {
                    sh """
                        echo "\${DOCKERHUB_CREDS_PSW}" | docker login \
                            --username "\${DOCKERHUB_CREDS_USR}" \
                            --password-stdin \
                            ${DOCKERHUB_REGISTRY}
                        
                        docker push ${IMAGE_BASE}:${TAG_FULL}
                        docker push ${IMAGE_BASE}:${TAG_VERSION}
                        docker push ${IMAGE_BASE}:${MAJOR_VERSION}
                        
                        ${params.TAG_AS_LATEST ? "docker push ${IMAGE_BASE}:latest" : ""}
                        
                        docker logout
                        echo "✓ Images pushed successfully"
                    """
                }
            }
        }
        
        stage('Generate Report') {
            steps {
                script {
                    def metadata = [
                        container: CONTAINER_NAME,
                        version: params.APACHE_VERSION,
                        tags: [
                            "${IMAGE_BASE}:${TAG_FULL}",
                            "${IMAGE_BASE}:${TAG_VERSION}",
                            "${IMAGE_BASE}:${MAJOR_VERSION}"
                        ]
                    ]
                    
                    if (params.TAG_AS_LATEST) {
                        metadata.tags.add("${IMAGE_BASE}:latest")
                    }
                    
                    writeJSON file: 'build-metadata.json', json: metadata, pretty: 4
                    
                    echo """
╔═══════════════════════════════════════════════════════════════╗
║                    BUILD COMPLETE                             ║
╚═══════════════════════════════════════════════════════════════╝

Container: ${CONTAINER_NAME} ${params.APACHE_VERSION}

Images:
"""
                    metadata.tags.each { tag -> echo "  • ${tag}" }
                    
                    echo """
Quick test:
  docker pull ${IMAGE_BASE}:${TAG_VERSION}
  docker run -d -p 8080:8080 ${IMAGE_BASE}:${TAG_VERSION}
  curl http://localhost:8080
═══════════════════════════════════════════════════════════════
"""
                }
            }
        }
    }
    
    post {
        always {
            script {
                try {
                    archiveArtifacts artifacts: '*.json', allowEmptyArchive: true
                } catch (Exception e) {
                    echo "No artifacts to archive"
                }
                
                try {
                    container('debian') {
                        sh "docker logout ${DOCKERHUB_REGISTRY} || true"
                        sh "docker system prune -af || true"
                    }
                } catch (Exception e) {
                    echo "Cleanup skipped"
                }
            }
        }
        
        success {
            echo "✓ BUILD SUCCESSFUL"
        }
        
        failure {
            echo "✗ BUILD FAILED - Check console output"
        }
    }
}
